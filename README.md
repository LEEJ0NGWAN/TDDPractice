## 포인트 충전/사용 기능 동시성 제어 방식 분석

### 개요

`PointService` 클래스의 `updatePoint`(포인트 충전/사용 기능의 내부 공통 로직) 메소드는 사용자 포인트를 동시에 업데이트할 때 발생할 수 있는 경쟁 상태를 방지하기 위해 커스텀 동시성 제어 메커니즘을 구현합니다.  
이 메커니즘은 Spring의 `@Transactional`과 같은 외부 트랜잭션 시스템에 의존하지 않고도 데이터 무결성을 보장하는 것을 목표로 두고 있습니다.

### 동시성 제어 메커니즘

updatePoint 메소드는 다음과 같은 기법을 사용합니다

#### 1. ConcurrentHashMap을 활용한 상태 관리

- key: 사용자 ID `Long`

- value: 실시간 다중 스레드로 인해 갱신되는 사용자 포인트 `AtomicLong`

  각 사용자는 자신의 AtomicLong 객체를 통해 포인트를 관리하며, 이로써 사용자별로 스레드 안전한 접근이 가능합니다.

#### 2. AtomicLong의 CAS(Compare-And-Swap) 사용  

- 다중 스레드의 포인트 업데이트는 AtomicLong.compareAndSet 메소드를 사용해 원자적으로 수행됩니다.

- CAS는 cpu의 원자 연산을 통해 한 번에 한 스레드만 값을 성공적으로 변경할 수 있도록 보장합니다.

#### 3. 재시도 로직

- updatePoint 메소드는 설정 가능한 최대 재시도 횟수`properties.getMaximumUpdateTryCount()` 만큼 갱신을 시도합니다.

- 높은 경쟁 상황에서 CAS 실패 시 최대 재시도 횟수 만큼 재시도를 수행합니다.

#### 4. ConcurrentHashMap 맵 정리 로직

- 업데이트 작업이 완료된 후, 다른 스레드가 참조하지 않는 경우 ConcurrentHashMap에 해당 사용자의 엔트리를 삭제합니다.

- 이를 위해 computeIfPresent를 사용하여 현재 값이 DB 상태와 일치하는지 확인하고, 일치한다면 엔트리를 제거합니다. (다른 스레드에서 아직 사용 중 인지 검사 후 제거)

### 장점

- 스레드 안전한 업데이트  
  ConcurrentMap과 AtomicLong의 조합을 통해 사용자 포인트 업데이트의 스레드 안전성을 보장합니다.

- 효율적인 리소스 사용  
  ConcurrentMap의 엔트리는 필요 시에만 추가되고, 사용 후 제거되어 메모리 사용을 최소화합니다.

- 설정 가능성  
  최대 재시도 횟수(MaximumUpdateTryCount)를 설정하여 다양한 시스템 요구사항에 맞게 조정할 수 있습니다.

### 잠재적인 문제점 및 고려사항

#### 1. 높은 경쟁 상태  

- 동일한 사용자의 포인트에 대해 많은 스레드가 동시에 업데이트를 시도하는 경우, 잦은 실패와 재시도로 성능이 저하될 수 있습니다.

- 해결책: 백오프(backoff) 전략 또는 재시도 로직 최적화.

#### 2. 지연 시간 증가  

- 정리 로직은 추가적인 DB 호출(selectById)을 포함하므로, 높은 부하 상황에서 지연 시간이 증가할 수 있습니다.

- 해결책: 자주 참조되는 데이터는 캐싱을 통해 최적화.

### 결론

updatePoint 메소드는 다중 스레드 환경에서 포인트 업데이트를 안전하게 처리할 수 있는 효과적인 동시성 제어 메커니즘을 구현합니다. ConcurrentMap과 AtomicLong을 활용하여 간단하면서도 확장 가능한 동작을 보장하며, 추가적인 최적화는 경쟁 상태와 지연 시간 문제를 해결하는 데 초점을 맞출 수 있습니다.

